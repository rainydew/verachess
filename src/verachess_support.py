#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 4.20
#  in conjunction with Tcl version 8.6
#    Oct 06, 2019 11:52:10 PM CST  platform: Windows NT
import sys
import os
import easygui
import pyperclip
import c960confirm
import clockconfirm
import setboard
import gameinfo
import chart
import re
from clock import refresh_clock
from verachess_global import Globals, release_model_lock
from typing import List, Tuple, Dict, Any
from verachess import destroy_MainWindow
from consts import Pieces, Positions, MenuStatNames, EndType, Winner, Color, Paths, CpuMoveConf, Role, \
    EndTypeToTermination, PGNModel, Winner_Dict, EndTypeToTerminationPGN, Chess960PGNModel, SetupPGNModel, \
    Reverse_Winner_Dict, Termination, TerminationPGNToTermination, EndTypeToInfo
from tkinter import CallWrapper
from decos import check_model, model_locked
import events

try:
    import Tkinter as tk
except ImportError:
    import tkinter as tk

try:
    import ttk

    py3 = False
except ImportError:
    import tkinter.ttk as ttk

    py3 = True

CellValues = ...  # type: List[List[tk.StringVar]]
MenuStats = {}  # type: Dict[str, tk.BooleanVar]
Eco = WhitePlayerInfo = BlackPlayerInfo = WhiteTotalTime = BlackTotalTime = WhiteUseTime = BlackUseTime = \
    DemoStat = AnlyStat = MonitorStat = PieceDiff = TerminateInfo = ...  # type: tk.StringVar
WhiteFlagImg = BlackFlagImg = ...  # type: tk.PhotoImage
MoveScaleVar = ...  # type: tk.IntVar
FlagWidth = 54  # modify it if you want


def set_Tk_var():
    global CellValues, MenuStats, Eco, WhitePlayerInfo, BlackPlayerInfo, WhiteTotalTime, BlackTotalTime, WhiteUseTime, \
        BlackUseTime, WhiteFlagImg, BlackFlagImg, MoveScaleVar, DemoStat, AnlyStat, MonitorStat, PieceDiff, \
        TerminateInfo
    CellValues = [[tk.StringVar(value="") for _ in range(8)] for _ in range(8)]
    MenuStats[MenuStatNames.flip] = tk.BooleanVar(value=False)
    MenuStats[MenuStatNames.clock] = tk.BooleanVar(value=True)
    Eco = tk.StringVar()
    Eco.set('A00 Start Position')
    WhitePlayerInfo = tk.StringVar()
    WhitePlayerInfo.set('人类')
    BlackPlayerInfo = tk.StringVar()
    BlackPlayerInfo.set('人类')
    WhiteTotalTime = tk.StringVar()
    WhiteTotalTime.set("00 : 05 : 00")
    BlackTotalTime = tk.StringVar()
    BlackTotalTime.set("00 : 05 : 00")
    WhiteUseTime = tk.StringVar()
    WhiteUseTime.set("00 : 00")
    BlackUseTime = tk.StringVar()
    BlackUseTime.set("00 : 00")
    WhiteFlagImg = tk.PhotoImage()
    WhiteFlagImg.configure(file=Paths.flag + "china.gif")
    BlackFlagImg = tk.PhotoImage()
    BlackFlagImg.configure(file=Paths.flag + "china.gif")
    MoveScaleVar = tk.IntVar()
    MoveScaleVar.set(0)
    DemoStat = tk.StringVar()
    DemoStat.set('引擎自弈')
    AnlyStat = tk.StringVar()
    AnlyStat.set('局面分析')
    MonitorStat = tk.StringVar()
    MonitorStat.set('可用内存\n0 MB')
    PieceDiff = tk.StringVar()
    PieceDiff.set("\n")
    TerminateInfo = tk.StringVar()
    TerminateInfo.set("棋局状态：{}\n{}".format(Winner_Dict.get(Globals.Winner), EndTypeToInfo.get(Globals.Game_end)))


class Hooks:
    WPlayer = "WPlayer"
    BPlayer = "BPlayer"
    WElo = "WElo"
    BElo = "BElo"
    WType = "WType"
    BType = "BType"
    Event = "Event"
    Site = "Site"
    Round = "Round"
    Result = "Result"
    Date = "Date"
    MTime = "MTime"
    TCMin = "TCMin"
    TCSec = "TCSec"
    Termination = "Termination"
    TDetail = "TDetail"
    SScore = "SScore"
    SDepth = "SDepth"
    STime = "STime"
    SNodes = "SNodes"
    SNps = "SNps"
    STb = "STb"
    SPv = "SPv"

    @staticmethod
    def _refresh_player_label():
        WElo = Globals.GameInfo.get(Hooks.WElo)
        BElo = Globals.GameInfo.get(Hooks.BElo)
        WPlayer = Globals.GameInfo.get(Hooks.WPlayer)
        BPlayer = Globals.GameInfo.get(Hooks.BPlayer)
        WType = Globals.GameInfo.get(Hooks.WType)
        BType = Globals.GameInfo.get(Hooks.BType)

        if WType == Role.human:
            w = "人类"
        elif WType == Role.computer:
            w = "引擎"
        else:
            w = "联机"
        if BType == Role.human:
            b = "人类"
        elif BType == Role.computer:
            b = "引擎"
        else:
            b = "联机"

        if WPlayer:
            w += " " + WPlayer
        if BPlayer:
            b += " " + BPlayer

        if WElo:
            w += " ({})".format(WElo)
        if BElo:
            b += " ({})".format(BElo)

        try:
            WhitePlayerInfo.set(w)
            BlackPlayerInfo.set(b)
        except AttributeError:
            print("only for gameinfo test mode, should be error when running real verachess")
            print("white label", w)
            print("black label", b)
        # need refresh hints after calling me, flags may be changed

    @staticmethod
    def update_game_info():
        info = Globals.GameInfo

        info[Hooks.WType] = Globals.Game_role["w"]
        info[Hooks.BType] = Globals.Game_role["b"]

        info[Hooks.WPlayer] = Globals.WName
        info[Hooks.BPlayer] = Globals.BName

        info[Hooks.Result] = Globals.Winner
        info[Hooks.Termination] = EndTypeToTermination.get(Globals.Game_end)

        Hooks._refresh_player_label()

    @staticmethod
    def update_globals():
        # player info
        WType = Globals.GameInfo.get(Hooks.WType)
        BType = Globals.GameInfo.get(Hooks.BType)
        WPlayer = Globals.GameInfo.get(Hooks.WPlayer)
        BPlayer = Globals.GameInfo.get(Hooks.BPlayer)

        Globals.Game_role["w"] = WType
        Globals.Game_role["b"] = BType

        Globals.WName = WPlayer
        Globals.BName = BPlayer

        # result
        Result = Globals.GameInfo.get(Hooks.Result)
        if Globals.Winner != Result:
            Globals.Winner = Result
            if Result == Winner.draw:
                Globals.Game_end = EndType.adjunction_draw
            elif Result == Winner.unknown:
                Globals.Game_end = EndType.unterminated
            else:
                Globals.Game_end = EndType.adjunction_win

        # tc will not async here. elo will not save in the game, but read in PGN or tournament file(to plan)
        Hooks._refresh_player_label()


def set_cell_values_and_diff(narrow_fen: str):
    rows = narrow_fen.split("/")
    assert len(rows) == 8, "error fen"
    nums = {x.lower(): 0 for x in Pieces}
    w_diff = ""
    b_diff = ""
    for i, row in enumerate(rows):
        j = 0
        for char in row:
            if char in Pieces:
                CellValues[i][j].set(Pieces[char])
                j += 1
                if char.isupper():
                    nums[char.lower()] += 1
                else:
                    nums[char] -= 1
            else:
                [CellValues[i][r].set("") for r in range(j, j + int(char))]
                j += int(char)  # if this errors, char is illegal
    for piece in "kqrbnp":
        np = nums[piece]
        if np > 0:
            w_diff += Pieces[piece.upper()] * np
        elif np < 0:
            b_diff += Pieces[piece] * -np

    PieceDiff.set("{}\n{}".format(w_diff, b_diff))


def set_cell_color(cell: Tuple[int, int] = None, color=Color.black, flush_all=False):
    main = Globals.Main
    if flush_all:
        [main.Cells[cell_r][cell_c].configure(foreground=Color.black) for cell_r in range(8) for cell_c in range(8)]
    if cell:
        r, c = cell
        main.Cells[r][c].configure(foreground=color)


def set_player_color(white: bool):
    main = Globals.Main
    main.Holder.configure(foreground=Color.white if white else Color.black)


def set_cell_back_colors(active_color_list: List[Tuple[int, int]] = None, inactive_color_list: List[Tuple[int, int]] =
None, flush_all=False):
    """
    :param active_color_list: 
    :param inactive_color_list: 
    :param flush_all: 
    :return: 
    """
    main = Globals.Main
    if flush_all:
        [main.Cells[r][c].configure(background=Color.yellow_dark if (r + c) % 2 else Color.yellow_light) for r in
         range(8)
         for c in range(8)]
    if inactive_color_list:  # deselect old first
        for r, c in inactive_color_list:
            main.Cells[r][c].configure(background=Color.yellow_dark if (r + c) % 2 else Color.yellow_light)
    if active_color_list:
        for r, c in active_color_list:
            main.Cells[r][c].configure(background=Color.cell_sel_dark if (r + c) % 2 else Color.cell_sel_light)


def refresh_flip():
    arg = MenuStats[MenuStatNames.flip].get()
    main = Globals.Main
    now_flip = main.Rows[0].winfo_y() != 0
    if arg != now_flip:
        if not arg:
            for r in range(8):
                main.Rows[r].place(y=r * 48)
                main.Columns[r].place(x=r * 48)
                for c in range(8):
                    main.Cells[r][c].place(x=c * 48, y=r * 48)
        else:
            for r in range(8):
                main.Rows[7 - r].place(y=r * 48)
                main.Columns[7 - r].place(x=r * 48)
                for c in range(8):
                    main.Cells[7 - r][7 - c].place(x=c * 48, y=r * 48)


def clear_sunken_cell():
    if Globals.SunkenCell:
        r, c = Globals.SunkenCell
        Globals.Main.Cells[r][c].configure(relief="groove")
        Globals.SunkenCell = None


def set_sunken_cell(place: Tuple[int, int]):
    assert Globals.SunkenCell is None
    Globals.SunkenCell = place
    r, c = place
    Globals.Main.Cells[r][c].configure(relief="sunken")


def reformat_fen(fen: str):
    li = fen.split(" ")
    castle = li[2]
    if castle == "-":
        return fen
    if "k" in castle.lower() or "q" in castle.lower():
        li[2] = "".join(sorted(castle))
    else:
        li[2] = "".join(sorted(castle))[::-1].swapcase()
    return " ".join(li)


def set_game_fen(fen: str):
    Globals.GameFen = fen
    Globals.White = fen.split(" ")[1] == "w"
    Globals.History = [fen]
    Globals.InfoHistory = []
    Globals.AlphabetMovelist = []
    Globals.PGNMovelist = []
    Globals.History_hash = [hash(" ".join(fen.split(" ")[:4]))]
    Globals.Game_end = EndType.unterminated
    Globals.Winner = Winner.unknown
    Globals.Game_role = {"w": Role.human, "b": Role.human}
    Globals.WName = Globals.BName = ""
    Globals.TerminationInfo = ""
    WhitePlayerInfo.set("人类")
    BlackPlayerInfo.set("人类")
    if fen == Positions.common_start_fen:
        Globals.Start_pos = Positions.name_normal_startpos
    else:
        Globals.Start_pos = fen
    Globals.MoveSlider = -1
    Hooks.update_game_info()
    events.remove_pgn_from()
    events.refresh_start_pos_in_movelist()
    events.clear_check_cell()
    events.refresh_whole_board()
    set_cell_color(flush_all=True)
    clear_sunken_cell()
    redraw_c960_flags()
    if fen != Positions.common_start_fen:
        events.check_wdl()
    else:
        events.refresh_end_type()


def redraw_c960_flags():
    columns = Globals.Main.Columns
    lr, k, rr = Globals.Chess_960_Columns
    for column in columns:
        column.configure(foreground=Color.black)
    if lr is not None:  # pasted c960 fen may return None
        columns[lr].configure(foreground=Color.orange)
    if rr is not None:  # too
        columns[rr].configure(foreground=Color.orange)
    if k is not None:  # too
        columns[k].configure(foreground=Color.magenta)


def reset_clock():
    clock_switch(reset=True)
    Globals.Wremain = Globals.Wtime
    Globals.Bremain = Globals.Btime
    Globals.Wuse = 0
    Globals.Buse = 0
    refresh_clock()


def refresh_clock_conf():
    conf = Globals.ClockConf
    Globals.Wtime = (conf.get('WhiteMinEntry') * 60 + conf.get('WhiteSecEntry')) * 1000
    Globals.Winc = conf.get('WhiteIncEntry') * 1000
    if conf.get('Sync'):
        Globals.Btime = Globals.Wtime
        Globals.Binc = Globals.Winc
    else:
        Globals.Btime = (conf.get('BlackMinEntry') * 60 + conf.get('BlackSecEntry')) * 1000
        Globals.Binc = conf.get('BlackIncEntry') * 1000
    Globals.CpuRebal = conf.get('CpuRebal')
    Globals.Cmv = {"UseDepth": CpuMoveConf.use_depth, "UseTimer": CpuMoveConf.use_timer, "UseNode": CpuMoveConf.use_node
                   }[conf.get("Cmv")]
    cpu_set = conf.get('CpuSet')
    if Globals.Cmv == CpuMoveConf.use_depth:
        Globals.CpuSet = int(cpu_set)
    elif Globals.Cmv == CpuMoveConf.use_timer:
        Globals.CpuSet = int(cpu_set * 1000)
    else:
        Globals.CpuSet = int(cpu_set * 1000000)
    reset_clock()


def format_pgn_file(info: Dict[str, Any] = Globals.GameInfo):
    eco_info = Eco.get().split(" ")
    eco, eco_msg = eco_info[0], eco_info[1:]
    res = PGNModel.format(
        info.get(Hooks.Event),
        info.get(Hooks.Site),
        info.get(Hooks.Date),
        info.get(Hooks.Round),
        info.get(Hooks.WPlayer),
        info.get(Hooks.BPlayer),
        info.get(Hooks.MTime),
        Winner_Dict[info.get(Hooks.Result)],
        info.get(Hooks.WElo),
        info.get(Hooks.BElo),
        eco,
        eco_msg,
        len(Globals.AlphabetMovelist),
        EndTypeToTerminationPGN.get(Globals.Game_end),
        Globals.TerminationInfo,
        Globals.Wtime // 1000 if Globals.Wtime == Globals.Btime else "?", Globals.Winc // 1000 if Globals.Winc == Globals.Binc else "?",
    )
    if Globals.Chess_960_Columns[0] is not None:
        res += Chess960PGNModel.format(Globals.Start_pos)
    elif Globals.Start_pos != Positions.name_normal_startpos:
        res += SetupPGNModel.format(Globals.Start_pos)
    return res


def parse_pgn_file(header: Dict[str, str]) -> Dict[str, Any]:
    info = {}
    info[Hooks.WPlayer] = header.get('white') or ''
    info[Hooks.BPlayer] = header.get('black') or ''
    info[Hooks.WElo] = header.get('whiteelo') or ''
    info[Hooks.BElo] = header.get('blackelo') or ''
    info[Hooks.WType] = Role.human
    info[Hooks.BType] = Role.human
    info[Hooks.Event] = header.get('event') or ''
    info[Hooks.Site] = header.get('site') or 'verachess 5.0'
    info[Hooks.Round] = header.get('round') or ''
    info[Hooks.Result] = Reverse_Winner_Dict.get(header.get('result')) or Winner.unknown
    info[Hooks.Date] = header.get('date') or ''
    info[Hooks.MTime] = header.get('time') or ''
    tc = header.get('timecontrol')
    if not tc:
        info[Hooks.TCMin] = 5.0
        info[Hooks.TCSec] = 3.0
    else:
        tc = tc.split("+")
        info[Hooks.TCMin] = float(tc[0]) / 60
        if len(tc) == 1:
            info[Hooks.TCSec] = 0.0
        else:
            info[Hooks.TCSec] = float(tc[1])
    term = header.get('termination')
    term = TerminationPGNToTermination.get(term)
    if not term:
        if info[Hooks.Result] == Winner.unknown:
            term = Termination.unterminated
        else:
            term = Termination.adjunction
    info[Hooks.Termination] = term
    info[Hooks.TDetail] = header.get('terminationdetails') or ''
    return info


# events
def exit_game():
    if easygui.ynbox("你确定要退出吗？", "verachess 5.0", ["是", "否"]):
        destroy_MainWindow()


@model_locked
def new_normal():
    if any(Globals.Game_role.values()) and not Globals.Game_end:
        easygui.msgbox("如果棋局正在进行，则黑白双方都需要被本地玩家控制，才能重新开局。请先将黑白双方均设为人类")
        return
    if easygui.ynbox("这将重置当前棋局信息，确认重新开始棋局吗？", "verachess 5.0", ["是", "否"]):
        Globals.Chess_960_Columns = (None, None, None)
        set_game_fen(Positions.common_start_fen)
        reset_clock()
        MenuStats[MenuStatNames.flip].set(False)
        refresh_flip()


@model_locked
def new_c960():
    if any(Globals.Game_role.values()) and not Globals.Game_end:
        easygui.msgbox("如果棋局正在进行，则黑白双方都需要被本地玩家控制，才能重新开局。请先将黑白双方均设为人类")
        return
    if easygui.ynbox("这将重置当前棋局信息，确认重新开始棋局吗？", "verachess 5.0", ["是", "否"]):
        main_window = Globals.Main.Top
        sub_window, confirm_widget = c960confirm.create_Toplevel1(root=main_window)
        sub_window.transient(main_window)  # show only one window in taskbar
        sub_window.grab_set()  # set as model window
        main_window.wait_window(sub_window)  # wait for window return, to get return value
        res = confirm_widget.Result

        if res is None:
            return
        rkr, pos = res
        Globals.Chess_960_Columns = rkr  # 新局面不走校验逻辑，必须手动设置chess960的易位列
        set_game_fen(pos)
        reset_clock()
        MenuStats[MenuStatNames.flip].set(False)
        refresh_flip()


@model_locked
def change_clock():
    if any(Globals.Game_role.values()):
        easygui.msgbox("黑白双方都需要处于被玩家控制的状态，且不使用FICS联网时，才能设置棋钟。请先将黑白双方均设为人类")
        return
    main_window = Globals.Main.Top
    sub_window, confirm_widget = clockconfirm.create_Toplevel1(root=main_window, **Globals.ClockConf)
    # 考虑子窗体独立测试需要，禁止子窗体直接访问需要初始化的Globals变量
    sub_window.transient(main_window)  # show only one window in taskbar
    sub_window.grab_set()  # set as model window
    main_window.wait_window(sub_window)  # wait for window return, to get return value
    res = confirm_widget.Result

    if res is None:
        return
    Globals.ClockConf = res
    refresh_clock_conf()


def flip():
    # this is event for flip click
    refresh_flip()


def clock_switch(reset: bool = False):
    clock_disabled = MenuStats[MenuStatNames.clock]
    if reset:
        clock_disabled.set(True)
    if clock_disabled.get():
        Globals.Main.WhiteUse.configure(background=Color.clock_disabled)
        Globals.Main.BlackUse.configure(background=Color.clock_disabled)
        Globals.Main.WhiteTotal.configure(background=Color.clock_inactive)
        Globals.Main.BlackTotal.configure(background=Color.clock_inactive)
    else:
        Globals.Main.WhiteUse.configure(background=Color.clock_enabled)
        Globals.Main.BlackUse.configure(background=Color.clock_enabled)
        if Globals.White:
            Globals.Main.WhiteTotal.configure(background=Color.clock_active)
            Globals.Main.BlackTotal.configure(background=Color.clock_inactive)
        else:
            Globals.Main.WhiteTotal.configure(background=Color.clock_inactive)
            Globals.Main.BlackTotal.configure(background=Color.clock_active)


@model_locked
def copy_fen():
    pyperclip.copy(Globals.GameFen)
    easygui.msgbox("当前局面已经复制到剪贴板")


@model_locked
def paste_fen():
    if any(Globals.Game_role.values()) and not Globals.Game_end:
        easygui.msgbox("如果棋局正在进行，则黑白双方都需要被本地玩家控制，才能编辑棋谱信息")
        return
    elif not easygui.ynbox("将会重置当前棋局的信息，你确认要导入局面吗？", "verachess 5.0", ["是", "否"]):
        return
    fen = pyperclip.paste()
    res, msg = events.check_fen_format_valid(fen)  # 校验格式，如果chess960的局面校验通过，会设置chess960的易位列
    if not res:
        easygui.msgbox("FEN错误\n" + msg)
        return
    release_model_lock()  # very important, set fen require model lock
    set_game_fen(reformat_fen(fen))


@model_locked
def set_board():
    if any(Globals.Game_role.values()) and not Globals.Game_end:
        easygui.msgbox("如果棋局正在进行，则黑白双方都需要被本地玩家控制，才能编辑棋谱信息")
        return
    main_window = Globals.Main.Top
    sub_window, setboard_widget = setboard.create_Toplevel1(root=main_window)
    sub_window.transient(main_window)  # show only one window in taskbar
    sub_window.grab_set()  # set as model window
    main_window.wait_window(sub_window)  # wait for window return, to get return value
    fen = setboard_widget.Result

    if fen is None:
        return
    release_model_lock()  # very important, set fen require model lock
    set_game_fen(reformat_fen(fen))
    MenuStats[MenuStatNames.flip].set(False)
    refresh_flip()


@model_locked
def edit_game():
    if any(Globals.Game_role.values()) and not Globals.Game_end:
        easygui.msgbox("如果棋局正在进行，则黑白双方都需要被本地玩家控制，才能编辑对局信息")
        return
    main_window = Globals.Main.Top
    sub_window, setboard_widget = gameinfo.create_Toplevel1(root=main_window)
    sub_window.transient(main_window)  # show only one window in taskbar
    sub_window.grab_set()  # set as model window
    main_window.wait_window(sub_window)  # wait for window return, to get return value
    info = setboard_widget.Result

    if info is None:
        return
    release_model_lock()  # very important, set fen require model lock

    Globals.GameInfo = info
    Hooks.update_globals()


@model_locked
def save_game():
    filepath = easygui.filesavebox("选择保存路径", "保存棋局", Paths.binpath + "/../PGN/*.pgn")
    if filepath is None:
        return
    Hooks.update_game_info()
    with open(filepath, "w") as f:
        f.write(format_pgn_file())
        f.write("\n")
        f.write(" ".join(Globals.PGNMovelist))
        f.write("  " + Winner_Dict[Globals.GameInfo.get(Hooks.Result)] + "\n\n")


@model_locked
def load_game():
    if any(Globals.Game_role.values()) and not Globals.Game_end:
        easygui.msgbox("如果棋局正在进行，则黑白双方都需要被本地玩家控制，才能导入棋谱文件")
        return
    filepath = easygui.fileopenbox("选择棋谱文件", "读取棋局", Paths.binpath + "/../PGN/*.pgn")
    if filepath is None:
        return
    header = "header"
    body = "body"
    pgns = []
    in_body = True
    with open(filepath, "r") as f:
        for line in f:
            if line:
                if "[" in line:
                    if in_body:
                        pgns.append({header: {}, body: ""})
                        in_body = False
                    field, value = re.findall('\[(.+) "(.*)"\]', line)[0]
                    pgns[-1][header][field] = value
                else:
                    in_body = True
                    if not len(pgns):
                        easygui.msgbox("PGN格式不正确，无法识别")
                        return
                    pgns[-1][body] += line
    if len(pgns) > 1:
        main_window = Globals.Main.Top
        sub_window, chart_widget = chart.create_Toplevel1(root=main_window, pgns=pgns)
        sub_window.transient(main_window)  # show only one window in taskbar
        sub_window.grab_set()  # set as model window
        main_window.wait_window(sub_window)  # wait for window return, to get return value
        pgn_index = chart_widget.Result
        if pgn_index is None:
            return
        choosen_pgn = pgns[int(pgn_index)]
    else:
        choosen_pgn = pgns[0]
    header, pgn = choosen_pgn.get("header"), choosen_pgn.get("body").strip()
    header = {k.lower(): v for k, v in header.items()}
    pgn = re.sub("(\{[^\}]*\})", "", pgn)
    pgn = [x.split(".")[-1] for x in pgn.split() if x[-1] != "."]
    if pgn[-1] in ('1-0', '0-1', '1/2-1/2', '*'):
        pgn = pgn[:-1]

    # print("pgn:", pgn)
    fen = header.get("fen") or Positions.common_start_fen
    res, msg = events.check_fen_format_valid(fen)  # 校验格式，如果chess960的局面校验通过，会设置chess960的易位列
    if not res:
        easygui.msgbox("FEN错误\n" + msg)
        return

    # load position
    release_model_lock()
    set_game_fen(reformat_fen(fen))
    reset_clock()
    MenuStats[MenuStatNames.flip].set(False)
    refresh_flip()

    # load moves
    res = events.pgn_move(pgn)
    if res:
        easygui.msgbox("棋谱解析错误，只解析到出错之前的局面。出错信息\n" + res, "警告")

    # load globals
    Globals.GameInfo = parse_pgn_file(header)
    Hooks.update_globals()


def adjunction(winner: float):
    assert winner in (0, 0.5, 1), "wrong winner"

    @model_locked
    def inner():
        if Role.remote in Globals.Game_role.values() or Globals.Game_role['w'] != Globals.Game_role['b'] or Globals.Game_end:
            easygui.msgbox("不能修改已经结束的棋局、FICS联网棋局和人机对战的结果\n"
                           "只能裁定双方都是人类或双方都是引擎的棋局")
            return
        elif not easygui.ynbox("本局将中止，不能再继续，确定吗？", "verachess 5.0", ["是", "否"]):
            return
        Globals.Winner = winner
        Globals.TerminationInfo = "user adjunction"
        Globals.Game_end = EndType.adjunction_win if winner != 0.5 else EndType.adjunction_draw
        events.refresh_end_type()
    return inner


@model_locked
def resign():
    mover = Globals.GameFen.split()[1]
    if Globals.Game_role.get(mover) or Globals.Game_end:
        easygui.msgbox("只有棋局处于进行中，且当前行棋方为人类时才可以认输")
        return
    elif not easygui.ynbox("认输后不能反悔，确定吗？", "verachess 5.0", ["是", "否"]):
        return
    if mover == "w":
        Globals.Winner = Winner.black
        Globals.TerminationInfo = "white resigns"
    else:
        Globals.Winner = Winner.white
        Globals.TerminationInfo = "black resigns"
    Globals.Game_end = EndType.resign
    events.refresh_end_type()


@check_model
def cell_click(event: CallWrapper) -> None:
    if Globals.Game_end:
        return
    place = Globals.Reverse_cell_names[str(event.widget)]
    events.click_handler(place)


@check_model
def move_click(event: CallWrapper) -> None:
    place = Globals.ReverseMoveNames[str(event.widget)]
    events.move_change_handler(place)


def ListScroll(value):
    value = int(float(value))

    MoveScaleVar.set(value)
    all_moves = Globals.Main.Moves

    for i, move in enumerate(all_moves):
        row = Globals.MoveRows[i]
        relative_row = row - value
        if relative_row >= 0:
            move.place(y=24 * relative_row)
        else:
            move.place(y=24 * relative_row - 24)     # hide, cannot use forget since we didn't save coordinate "x"!


def destruct(event: CallWrapper) -> None:
    if event.widget != Globals.Main.Moves[0]:   # the base movelist, if we remove it, the whole program will exit
        # when we bind it to top, it in fact was binded to all sub widgets under top!!!!
        # otherwise even we restart a game will cause os._exit, this was a bug
        return
    global WhiteFlagImg, BlackFlagImg
    try:
        del WhiteFlagImg
        del BlackFlagImg
    except NameError:
        pass
    os._exit(0)


def ChangeMonitor():
    print('verachess_support.ChangeMonitor')
    sys.stdout.flush()

def CmdAnalyze():
    print('verachess_support.CmdAnalyze')
    sys.stdout.flush()

def CmdDemo():
    print('verachess_support.CmdDemo')
    sys.stdout.flush()

def CmdEnd():
    print('verachess_support.CmdEnd')
    sys.stdout.flush()

def CmdFlip():
    print('verachess_support.CmdFlip')
    sys.stdout.flush()

def CmdInfo():
    print('verachess_support.CmdInfo')
    sys.stdout.flush()

def CmdLeft():
    print('verachess_support.CmdLeft')
    sys.stdout.flush()

def CmdRight():
    print('verachess_support.CmdRight')
    sys.stdout.flush()

def CmdStart():
    print('verachess_support.CmdStart')
    sys.stdout.flush()


# event end
def init(top, gui, *args, **kwargs):
    global w, top_level, root
    w = gui
    top_level = top
    root = top


def destroy_window():
    # Function which closes the window.
    if easygui.ynbox("你确定要退出吗？", "verachess 5.0", ["是", "否"]):
        destroy_MainWindow()
